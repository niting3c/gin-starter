// Code generated by mockery v2.42.0. DO NOT EDIT.

package mocks

import (
	pgx "github.com/jackc/pgx/v5"
	mock "github.com/stretchr/testify/mock"

	utils "starter/internal/app/utils"
)

// CRUDRepository is an autogenerated mock type for the CRUDRepository type
type CRUDRepository struct {
	mock.Mock
}

// BeginTransaction provides a mock function with given fields:
func (_m *CRUDRepository) BeginTransaction() (pgx.Tx, *utils.ErrorMessage) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for BeginTransaction")
	}

	var r0 pgx.Tx
	var r1 *utils.ErrorMessage
	if rf, ok := ret.Get(0).(func() (pgx.Tx, *utils.ErrorMessage)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() pgx.Tx); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pgx.Tx)
		}
	}

	if rf, ok := ret.Get(1).(func() *utils.ErrorMessage); ok {
		r1 = rf()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*utils.ErrorMessage)
		}
	}

	return r0, r1
}

// CommitTransaction provides a mock function with given fields: tx, objectType
func (_m *CRUDRepository) CommitTransaction(tx pgx.Tx, objectType string) *utils.ErrorMessage {
	ret := _m.Called(tx, objectType)

	if len(ret) == 0 {
		panic("no return value specified for CommitTransaction")
	}

	var r0 *utils.ErrorMessage
	if rf, ok := ret.Get(0).(func(pgx.Tx, string) *utils.ErrorMessage); ok {
		r0 = rf(tx, objectType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*utils.ErrorMessage)
		}
	}

	return r0
}

// Create provides a mock function with given fields: query, objectType, args
func (_m *CRUDRepository) Create(query string, objectType string, args ...interface{}) (interface{}, *utils.ErrorMessage) {
	var _ca []interface{}
	_ca = append(_ca, query, objectType)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 interface{}
	var r1 *utils.ErrorMessage
	if rf, ok := ret.Get(0).(func(string, string, ...interface{}) (interface{}, *utils.ErrorMessage)); ok {
		return rf(query, objectType, args...)
	}
	if rf, ok := ret.Get(0).(func(string, string, ...interface{}) interface{}); ok {
		r0 = rf(query, objectType, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, ...interface{}) *utils.ErrorMessage); ok {
		r1 = rf(query, objectType, args...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*utils.ErrorMessage)
		}
	}

	return r0, r1
}

// Delete provides a mock function with given fields: query, objectType, args
func (_m *CRUDRepository) Delete(query string, objectType string, args ...interface{}) *utils.ErrorMessage {
	var _ca []interface{}
	_ca = append(_ca, query, objectType)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 *utils.ErrorMessage
	if rf, ok := ret.Get(0).(func(string, string, ...interface{}) *utils.ErrorMessage); ok {
		r0 = rf(query, objectType, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*utils.ErrorMessage)
		}
	}

	return r0
}

// Get provides a mock function with given fields: query, objectType, mapper, args
func (_m *CRUDRepository) Get(query string, objectType string, mapper utils.RowMapperFunc, args ...interface{}) ([]interface{}, *utils.ErrorMessage) {
	var _ca []interface{}
	_ca = append(_ca, query, objectType, mapper)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []interface{}
	var r1 *utils.ErrorMessage
	if rf, ok := ret.Get(0).(func(string, string, utils.RowMapperFunc, ...interface{}) ([]interface{}, *utils.ErrorMessage)); ok {
		return rf(query, objectType, mapper, args...)
	}
	if rf, ok := ret.Get(0).(func(string, string, utils.RowMapperFunc, ...interface{}) []interface{}); ok {
		r0 = rf(query, objectType, mapper, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, utils.RowMapperFunc, ...interface{}) *utils.ErrorMessage); ok {
		r1 = rf(query, objectType, mapper, args...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*utils.ErrorMessage)
		}
	}

	return r0, r1
}

// GetOne provides a mock function with given fields: query, objectType, mapper, args
func (_m *CRUDRepository) GetOne(query string, objectType string, mapper utils.RowMapperFunc, args ...interface{}) (interface{}, *utils.ErrorMessage) {
	var _ca []interface{}
	_ca = append(_ca, query, objectType, mapper)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetOne")
	}

	var r0 interface{}
	var r1 *utils.ErrorMessage
	if rf, ok := ret.Get(0).(func(string, string, utils.RowMapperFunc, ...interface{}) (interface{}, *utils.ErrorMessage)); ok {
		return rf(query, objectType, mapper, args...)
	}
	if rf, ok := ret.Get(0).(func(string, string, utils.RowMapperFunc, ...interface{}) interface{}); ok {
		r0 = rf(query, objectType, mapper, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, utils.RowMapperFunc, ...interface{}) *utils.ErrorMessage); ok {
		r1 = rf(query, objectType, mapper, args...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*utils.ErrorMessage)
		}
	}

	return r0, r1
}

// GetWithPagination provides a mock function with given fields: countSQL, objectType, finalSQL, mapper, pagination, args
func (_m *CRUDRepository) GetWithPagination(countSQL string, objectType string, finalSQL string, mapper utils.RowMapperFunc, pagination *utils.Pagination, args ...interface{}) (*utils.Pagination, *utils.ErrorMessage) {
	var _ca []interface{}
	_ca = append(_ca, countSQL, objectType, finalSQL, mapper, pagination)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWithPagination")
	}

	var r0 *utils.Pagination
	var r1 *utils.ErrorMessage
	if rf, ok := ret.Get(0).(func(string, string, string, utils.RowMapperFunc, *utils.Pagination, ...interface{}) (*utils.Pagination, *utils.ErrorMessage)); ok {
		return rf(countSQL, objectType, finalSQL, mapper, pagination, args...)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, utils.RowMapperFunc, *utils.Pagination, ...interface{}) *utils.Pagination); ok {
		r0 = rf(countSQL, objectType, finalSQL, mapper, pagination, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*utils.Pagination)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, utils.RowMapperFunc, *utils.Pagination, ...interface{}) *utils.ErrorMessage); ok {
		r1 = rf(countSQL, objectType, finalSQL, mapper, pagination, args...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*utils.ErrorMessage)
		}
	}

	return r0, r1
}

// RollBackTransaction provides a mock function with given fields: tx, objectType
func (_m *CRUDRepository) RollBackTransaction(tx pgx.Tx, objectType string) *utils.ErrorMessage {
	ret := _m.Called(tx, objectType)

	if len(ret) == 0 {
		panic("no return value specified for RollBackTransaction")
	}

	var r0 *utils.ErrorMessage
	if rf, ok := ret.Get(0).(func(pgx.Tx, string) *utils.ErrorMessage); ok {
		r0 = rf(tx, objectType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*utils.ErrorMessage)
		}
	}

	return r0
}

// Update provides a mock function with given fields: query, objectType, args
func (_m *CRUDRepository) Update(query string, objectType string, args ...interface{}) *utils.ErrorMessage {
	var _ca []interface{}
	_ca = append(_ca, query, objectType)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *utils.ErrorMessage
	if rf, ok := ret.Get(0).(func(string, string, ...interface{}) *utils.ErrorMessage); ok {
		r0 = rf(query, objectType, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*utils.ErrorMessage)
		}
	}

	return r0
}

// NewCRUDRepository creates a new instance of CRUDRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCRUDRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *CRUDRepository {
	mock := &CRUDRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
